![](https://img.shields.io/badge/-ceph-green)
# 压缩列表
* Ziplist 是为了尽可能地节约内存而设计的特殊编码且内存连续的双向链表。
* Ziplist 可以储存字符串值和整数值，其中，整数值被保存为实际的整数，而不是字符数组。
* Ziplist 允许在列表的两端进行 O(1) 复杂度的 push 和 pop 操作。但是，因为这些操作都需要对整个 ziplist 进行内存重分配，所以实际的复杂度和 ziplist 占用的内存大小有关。
***
* ziplist 的一般布局：`<zlbytes><zltail><zllen><entry><entry><zlend>`
* `<zlbytes>` 是一个无符号整数，保存着 ziplist 使用的内存数量。通过这个值，程序可以直接对 ziplist 的内存大小进行调整，而无须为了计算 ziplist 的内存大小而遍历整个列表。
* `<zltail>` 保存着到达列表中最后一个节点的偏移量。这个偏移量使得对表尾的 pop 操作可以在无须遍历整个列表的情况下进行。
* `<zllen>` 保存着列表中的节点数量。当 zllen 保存的值大于 2**16-2 时，程序需要遍历整个列表才能知道列表实际包含了多少个节点。
* `<zlend> 的长度为 1 字节，值为 255 ，标识列表的末尾。`
***
* `entry` 是Ziplist的节点，每个 ziplist 节点的前面都带有一个 header ，这个 header 包含两部分信息
* 1)前置节点的长度，在程序从后向前遍历时使用。
* 2)当前节点所保存的值的类型和长度。
***
* 编码前置节点的长度的方法如下：
* 1) 如果前置节点的长度小于 254 字节，那么程序将使用 1 个字节来保存这个长度值。
* 2) 如果前置节点的长度大于等于 254 字节，那么程序将使用 5 个字节来保存这个长度值：a) 第 1 个字节的值将被设为 254 ，用于标识这是一个 5 字节长的长度值。 b) 之后的 4 个字节则用于保存前置节点的实际长度。
***
* header 另一部分的内容和节点所保存的值有关。
* 2如果节点保存的是字符串值，那么这部分header的头 2个位将保存编码字符串长度所使用的类型，而之后跟着的内容则是字符串的实际长度。
* 如果节点保存的是整数值，那么这部分 header 的头 2 位都将被设置为 1 ，而之后跟着的 2 位则用于标识节点所保存的整数的类型
***
* zrealloc似乎可以再对连续的内存空间进行扩容，无多余空间时会改变对象的地址





